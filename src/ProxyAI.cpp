/* This file is part of the Spring engine (GPL v2 or later), see LICENSE.html */

#include "ProxyAI.h"


#include "ExternalAI/Interface/AISEvents.h"
#include "ExternalAI/Interface/AISCommands.h"

// generated by the C++ Wrapper scripts
#include "OOAICallback.h"
#include "Unit.h"
#include "UnitDef.h"
#include "Game.h"

#include <string>
#include<sys/socket.h>
#include<arpa/inet.h>
#include <vector>
#include "json.hpp"
#include "json_converters.h"

proxyai::ProxyAI::ProxyAI(springai::OOAICallback* callback, const struct SSkirmishAICallback* innerCallback):
    callback(callback),
    innerCallback(innerCallback),
    skirmishAIId(callback->GetSkirmishAIId()) {

    struct sockaddr_in server;
    sock = socket(AF_INET, SOCK_STREAM, 0);
    if (sock == -1) {
        perror("socket failed. Error");
        throw std::exception();
    }
    server.sin_addr.s_addr = inet_addr("127.0.0.1");
    server.sin_family = AF_INET;
    server.sin_port = htons(8765);
    if (connect(sock, (struct sockaddr *)&server , sizeof(server)) < 0) {
        perror("connect failed. Error");
        throw std::exception();
    }

}

proxyai::ProxyAI::~ProxyAI() {
    close(sock);
}


int proxyai::ProxyAI::ParseCommand(std::string json_string) {
    printf("[CMD]: %s\n", json_string.c_str());

    json command_json = json::parse(json_string);
    Command message = command_json;
    switch(message.command) {
    case COMMAND_NULL:
        break;
    case COMMAND_DRAWER_POINT_ADD:
        break;
    case COMMAND_DRAWER_LINE_ADD:
        break;
    case COMMAND_DRAWER_POINT_REMOVE:
        break;
    case COMMAND_SEND_START_POS:
        break;
    case COMMAND_CHEATS_SET_MY_INCOME_MULTIPLIER:
        break;
    case COMMAND_SEND_TEXT_MESSAGE: {
        SSendTextMessageCommand command = message.data;
        printf("%d %s\n", command.zone, command.text);
        (*(innerCallback->Engine_handleCommand))(skirmishAIId, COMMAND_TO_ID_ENGINE, 0, message.command, &command);
        break;
    }
    case COMMAND_SET_LAST_POS_MESSAGE:
        break;
    case COMMAND_SEND_RESOURCES:
        break;
    case COMMAND_SEND_UNITS:
        break;
    case COMMAND_UNUSED_0:
        break;
    case COMMAND_UNUSED_1:
        break;
    case COMMAND_GROUP_CREATE:
        break;
    case COMMAND_GROUP_ERASE:
        break;
    case COMMAND_GROUP_ADD_UNIT:
        break;
    case COMMAND_GROUP_REMOVE_UNIT:
        break;
    case COMMAND_PATH_INIT:
        break;
    case COMMAND_PATH_GET_APPROXIMATE_LENGTH:
        break;
    case COMMAND_PATH_GET_NEXT_WAYPOINT:
        break;
    case COMMAND_PATH_FREE:
        break;
    case COMMAND_CHEATS_GIVE_ME_RESOURCE:
        break;
    case COMMAND_CALL_LUA_RULES:
        break;
    case COMMAND_DRAWER_ADD_NOTIFICATION:
        break;
    case COMMAND_DRAWER_DRAW_UNIT:
        break;
    case COMMAND_DRAWER_PATH_START:
        break;
    case COMMAND_DRAWER_PATH_FINISH:
        break;
    case COMMAND_DRAWER_PATH_DRAW_LINE:
        break;
    case COMMAND_DRAWER_PATH_DRAW_LINE_AND_ICON:
        break;
    case COMMAND_DRAWER_PATH_DRAW_ICON_AT_LAST_POS:
        break;
    case COMMAND_DRAWER_PATH_BREAK:
        break;
    case COMMAND_DRAWER_PATH_RESTART:
        break;
    case COMMAND_DRAWER_FIGURE_CREATE_SPLINE:
        break;
    case COMMAND_DRAWER_FIGURE_CREATE_LINE:
        break;
    case COMMAND_DRAWER_FIGURE_SET_COLOR:
        break;
    case COMMAND_DRAWER_FIGURE_DELETE:
        break;
    case COMMAND_UNIT_BUILD:
        break;
    case COMMAND_UNIT_STOP:
        break;
    case COMMAND_UNIT_WAIT:
        break;
    case COMMAND_UNIT_WAIT_TIME:
        break;
    case COMMAND_UNIT_WAIT_DEATH:
        break;
    case COMMAND_UNIT_WAIT_SQUAD:
        break;
    case COMMAND_UNIT_WAIT_GATHER:
        break;
    case COMMAND_UNIT_MOVE: {
        SMoveUnitCommand command = message.data;
        printf("x: %f, y: %f, z: %f\n", command.toPos_posF3[0], command.toPos_posF3[1], command.toPos_posF3[2]);
        (*(innerCallback->Engine_handleCommand))(skirmishAIId, COMMAND_TO_ID_ENGINE, -1, message.command, &command);
        break;
    }
    case COMMAND_UNIT_PATROL:
        break;
    case COMMAND_UNIT_FIGHT:
        break;
    case COMMAND_UNIT_ATTACK:
        break;
    case COMMAND_UNIT_ATTACK_AREA:
        break;
    case COMMAND_UNIT_GUARD:
        break;
    case COMMAND_UNIT_AI_SELECT:
        break;
    case COMMAND_UNIT_GROUP_ADD:
        break;
    case COMMAND_UNIT_GROUP_CLEAR:
        break;
    case COMMAND_UNIT_REPAIR:
        break;
    case COMMAND_UNIT_SET_FIRE_STATE:
        break;
    case COMMAND_UNIT_SET_MOVE_STATE:
        break;
    case COMMAND_UNIT_SET_BASE:
        break;
    case COMMAND_UNIT_SELF_DESTROY:
        break;
    case COMMAND_UNIT_SET_WANTED_MAX_SPEED:
        break;
    case COMMAND_UNIT_LOAD_UNITS:
        break;
    case COMMAND_UNIT_LOAD_UNITS_AREA:
        break;
    case COMMAND_UNIT_LOAD_ONTO:
        break;
    case COMMAND_UNIT_UNLOAD_UNITS_AREA:
        break;
    case COMMAND_UNIT_UNLOAD_UNIT:
        break;
    case COMMAND_UNIT_SET_ON_OFF:
        break;
    case COMMAND_UNIT_RECLAIM_UNIT:
        break;
    case COMMAND_UNIT_RECLAIM_AREA:
        break;
    case COMMAND_UNIT_CLOAK:
        break;
    case COMMAND_UNIT_STOCKPILE:
        break;
    case COMMAND_UNIT_D_GUN:
        break;
    case COMMAND_UNIT_D_GUN_POS:
        break;
    case COMMAND_UNIT_RESTORE_AREA:
        break;
    case COMMAND_UNIT_SET_REPEAT:
        break;
    case COMMAND_UNIT_SET_TRAJECTORY:
        break;
    case COMMAND_UNIT_RESURRECT:
        break;
    case COMMAND_UNIT_RESURRECT_AREA:
        break;
    case COMMAND_UNIT_CAPTURE:
        break;
    case COMMAND_UNIT_CAPTURE_AREA:
        break;
    case COMMAND_UNIT_SET_AUTO_REPAIR_LEVEL:
        break;
    case COMMAND_UNIT_SET_IDLE_MODE:
        break;
    case COMMAND_UNIT_CUSTOM:
        break;
    case COMMAND_CHEATS_GIVE_ME_NEW_UNIT:
        break;
    case COMMAND_TRACE_RAY:
        break;
    case COMMAND_PAUSE:
        break;
    case COMMAND_UNIT_RECLAIM_FEATURE:
        break;
    case COMMAND_DEBUG_DRAWER_GRAPH_SET_POS:
        break;
    case COMMAND_DEBUG_DRAWER_GRAPH_SET_SIZE:
        break;
    case COMMAND_DEBUG_DRAWER_GRAPH_LINE_ADD_POINT:
        break;
    case COMMAND_DEBUG_DRAWER_GRAPH_LINE_DELETE_POINTS:
        break;
    case COMMAND_DEBUG_DRAWER_GRAPH_LINE_SET_COLOR:
        break;
    case COMMAND_DEBUG_DRAWER_GRAPH_LINE_SET_LABEL:
        break;
    case COMMAND_DEBUG_DRAWER_OVERLAYTEXTURE_ADD:
        break;
    case COMMAND_DEBUG_DRAWER_OVERLAYTEXTURE_UPDATE:
        break;
    case COMMAND_DEBUG_DRAWER_OVERLAYTEXTURE_DELETE:
        break;
    case COMMAND_DEBUG_DRAWER_OVERLAYTEXTURE_SET_POS:
        break;
    case COMMAND_DEBUG_DRAWER_OVERLAYTEXTURE_SET_SIZE:
        break;
    case COMMAND_DEBUG_DRAWER_OVERLAYTEXTURE_SET_LABEL:
        break;
    case COMMAND_TRACE_RAY_FEATURE:
        break;
    case COMMAND_CALL_LUA_UI:
        break;
    default:
        break;
    }
}

int proxyai::ProxyAI::ParseCommands() {
    int last_newline = 0, newline = 0;
    std::vector<std::string> commands;
    for(newline = 0; newline < current_pos; newline++) {
        if(buf[newline] == '\n') {
            printf("newline: %d last_newline: %d current_pos: %d\n", newline, last_newline, current_pos);
            std::string command_string(buf + last_newline, newline);
            commands.push_back(command_string);
            last_newline = newline + 1;
        }
    }
    printf("MEMCPY: %d, %d\n", last_newline, current_pos - last_newline);
    memcpy(buf, buf + last_newline, current_pos - last_newline);
    current_pos = current_pos - last_newline;
    for(auto const &command_string: commands) {
        ParseCommand(command_string);
    }
    return 0;
}

int proxyai::ProxyAI::ReceiveCommands() {
    int bytes = recv(sock, buf + current_pos, PROXYAI_BUF_SIZE - current_pos, MSG_DONTWAIT);

    //printf("BYTES: %d\n", bytes);
    if(bytes > 0) {
        printf("IN BUF: [%s]\n", std::string(buf, 0, current_pos).c_str());
        current_pos += bytes;
        return ParseCommands();
    } else if(bytes == 0) {
        // Disconnected
        return -1;
    }
}

int proxyai::ProxyAI::SendEvent(int topic, const void *data) {
    json j;
    bool send_event = true;
    switch (topic) {
    case EVENT_NULL:
        j = {{"topic", topic}, {"data", json{}}};
        break;
    case EVENT_INIT:
        j = {{"topic", topic}, {"data", *((SInitEvent *)data)}};
        break;
    case EVENT_RELEASE:
        j = {{"topic", topic}, {"data", *((SReleaseEvent *)data)}};
        break;
    case EVENT_UPDATE:
        j = {{"topic", topic}, {"data", *((SUpdateEvent *)data)}};
        ReceiveCommands();
        send_event = false;
        break;
    case EVENT_MESSAGE:
        j = {{"topic", topic}, {"data", *((SMessageEvent *)data)}};
        break;
    case EVENT_UNIT_CREATED:
        j = {{"topic", topic}, {"data", *((SUnitCreatedEvent *)data)}};
        break;
    case EVENT_UNIT_FINISHED:
        j = {{"topic", topic}, {"data", *((SUnitFinishedEvent *)data)}};
        break;
    case EVENT_UNIT_IDLE:
        j = {{"topic", topic}, {"data", *((SUnitIdleEvent *)data)}};
        break;
    case EVENT_UNIT_MOVE_FAILED:
        j = {{"topic", topic}, {"data", *((SUnitMoveFailedEvent *)data)}};
        break;
    case EVENT_UNIT_DAMAGED:
        j = {{"topic", topic}, {"data", *((SUnitDamagedEvent *)data)}};
        break;
    case EVENT_UNIT_DESTROYED:
        j = {{"topic", topic}, {"data", *((SUnitDestroyedEvent *)data)}};
        break;
    case EVENT_UNIT_GIVEN:
        j = {{"topic", topic}, {"data", *((SUnitGivenEvent *)data)}};
        break;
    case EVENT_UNIT_CAPTURED:
        j = {{"topic", topic}, {"data", *((SUnitCapturedEvent *)data)}};
        break;
    case EVENT_ENEMY_ENTER_LOS:
        j = {{"topic", topic}, {"data", *((SEnemyEnterLOSEvent *)data)}};
        break;
    case EVENT_ENEMY_LEAVE_LOS:
        j = {{"topic", topic}, {"data", *((SEnemyLeaveLOSEvent *)data)}};
        break;
    case EVENT_ENEMY_ENTER_RADAR:
        j = {{"topic", topic}, {"data", *((SEnemyEnterRadarEvent *)data)}};
        break;
    case EVENT_ENEMY_LEAVE_RADAR:
        j = {{"topic", topic}, {"data", *((SEnemyLeaveRadarEvent *)data)}};
        break;
    case EVENT_ENEMY_DAMAGED:
        j = {{"topic", topic}, {"data", *((SEnemyDamagedEvent *)data)}};
        break;
    case EVENT_ENEMY_DESTROYED:
        j = {{"topic", topic}, {"data", *((SEnemyDestroyedEvent *)data)}};
        break;
    case EVENT_WEAPON_FIRED:
        j = {{"topic", topic}, {"data", *((SWeaponFiredEvent *)data)}};
        break;
    case EVENT_PLAYER_COMMAND:
        j = {{"topic", topic}, {"data", *((SPlayerCommandEvent *)data)}};
        break;
    case EVENT_SEISMIC_PING:
        j = {{"topic", topic}, {"data", *((SCommandFinishedEvent *)data)}};
        break;
    case EVENT_COMMAND_FINISHED:
        j = {{"topic", topic}, {"data", *((SSeismicPingEvent *)data)}};
        break;
    case EVENT_LOAD:
        j = {{"topic", topic}, {"data", *((SLoadEvent *)data)}};
        break;
    case EVENT_SAVE:
        j = {{"topic", topic}, {"data", *((SSaveEvent *)data)}};
        break;
    case EVENT_ENEMY_CREATED:
        j = {{"topic", topic}, {"data", *((SEnemyCreatedEvent *)data)}};
        break;
    case EVENT_ENEMY_FINISHED:
        j = {{"topic", topic}, {"data", *((SEnemyFinishedEvent *)data)}};
        break;
    case EVENT_LUA_MESSAGE:
        j = {{"topic", topic}, {"data", *((SLuaMessageEvent *)data)}};
        break;
    default:
        printf("Unknown topic: %d\n", topic);
        break;
    }
    if(send_event) {
        std::string s = j.dump() + "\n";
        send(sock, s.data(), s.length(), MSG_DONTWAIT);
    }
    return 0;
}

int proxyai::ProxyAI::HandleEvent(int topic, const void* data) {
    try {
        return SendEvent(topic, data);
    } catch (const std::exception &e) {
        printf("ERROR: %s\n", e.what());
        throw e;
    }
}
